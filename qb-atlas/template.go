package main

import (
	"fmt"
	"io"
	"strings"
	"sync"
	"text/template"

	"ariga.io/atlas/sql/mysql"
	"ariga.io/atlas/sql/postgres"
	"ariga.io/atlas/sql/schema"
	"golang.org/x/text/cases"
	"golang.org/x/text/language"
)

const (
	qbTypeBool   = `qb.Bool`
	qbTypeInt    = `qb.Int`
	qbTypeFloat  = `qb.Float`
	qbTypeString = `qb.String`
	qbTypeDate   = `qb.Date`
)

func writeTemplate(wr io.Writer, schema *schema.Schema, pkg string) error {
	mut := &sync.Mutex{}
	tch := make(chan templateTable)

	for _, table := range schema.Tables {
		go newTempateTable(table, tch)
	}

	// Write header
	_, err := fmt.Fprintf(wr, `// This file is generated by git.ultraware.nl/NiseVoid/qb/qb-atlas. PLEASE DO NOT EDIT.

package `+pkg+`

import (
	"git.ultraware.nl/NiseVoid/qb"
)
`)
	if err != nil {
		return err
	}

	for i := 0; i < len(schema.Tables); i++ {
		if err := writeTable(wr, mut, <-tch); err != nil {
			return err
		}
	}

	close(tch)

	return nil
}

func writeTable(wr io.Writer, mut *sync.Mutex, table templateTable) error {
	mut.Lock()
	defer mut.Unlock()

	templ := template.Must(template.New("table").
		Funcs(template.FuncMap{
			`quote`: func(s string) string {
				return fmt.Sprintf("`%s`", s)
			},
			`title`: func(s string) string {
				switch s {
				case `id`, `sql`:
					return strings.ToUpper(s)
				default:
					return cases.Title(language.AmericanEnglish).
						String(s)
				}
			},
		}).
		Parse(tableTempl))

	return templ.Execute(wr, table)
}

func newTempateTable(table *schema.Table, ch chan templateTable) {
	t := templateTable{}
	t.Name = table.Name

	for _, col := range table.Columns {
		tc := templateColumn{}
		tc.Name = col.Name
		tc.Null = col.Type.Null

		switch typ := col.Type.Type.(type) {
		case *postgres.SerialType:
			tc.Type = qbTypeInt
		case *schema.IntegerType:
			tc.Type = qbTypeInt
		case *schema.BinaryType:
			tc.Type = qbTypeBool
		case *postgres.BitType:
			tc.Type = qbTypeString
			tc.Size = int(typ.Len)
		case *mysql.BitType:
			tc.Type = qbTypeString
			tc.Size = typ.Size
		case *schema.DecimalType:
			tc.Type = qbTypeFloat
			tc.Size = typ.Precision
		case *schema.FloatType:
			tc.Type = qbTypeFloat
			tc.Size = typ.Precision
		case *schema.TimeType:
			tc.Type = qbTypeDate
		case *schema.BoolType:
			tc.Type = qbTypeBool
		case *schema.StringType:
			tc.Type = qbTypeString
			tc.Size = typ.Size
		case *schema.EnumType:
			tc.Type = qbTypeString
			t.Enum = true
		default:
			tc.Type = qbTypeString
		}

		t.Columns = append(t.Columns, tc)
	}

	ch <- t
}

type templateTable struct {
	Name    string
	Enum    bool
	Columns []templateColumn
}

type templateColumn struct {
	Name string
	Type string
	Null bool
	Size int
}

const tableTempl = `
// {{title .Name}}
{{- if not .Enum}}
var (
	qb{{title .Name}}Table = qb.Table{Name: {{quote .Name}}}
	{{range .Columns}}
	qb{{title $.Name}}F{{title .Name}} = qb.TableField{Parent: &qb{{title $.Name}}Table, Name: {{quote .Name}}, Type: {{.Type}}
	{{- if gt .Size 0}}, Size: {{.Size}}{{end -}}
	{{- if .Null}}, Nullable: true{{end -}}
}{{end}}
)

// {{title .Name}}Type represents the table "{{.Name}}"
type {{title .Name}}Type struct {
{{- range .Columns}}
	{{title .Name}} qb.Field{{end}}

	table *qb.Table
}

// GetTable returns an object with info about the table
func (t *{{title .Name}}Type) GetTable() *qb.Table {
	return t.table
}
// Select starts a SELECT query
func (t *{{title .Name}}Type) Select(f ...qb.Field) *qb.SelectBuilder {
	return t.table.Select(f)
}
// Delete creates a DELETE query
func (t *{{title .Name}}Type) Delete(c1 qb.Condition, c ...qb.Condition) qb.Query {
	return t.table.Delete(c1, c...)
}
// Update starts a UPDATE query
func (t *{{title .Name}}Type) Update() *qb.UpdateBuilder {
	return t.table.Update()
}
// Insert starts a INSERT query
func (t *{{title .Name}}Type) Insert(f ...qb.Field) *qb.InsertBuilder {
	return t.table.Insert(f)
}
// {{title .Name}} returns a new {{title .Name}}Type
func {{title .Name}}() *{{title .Name}}Type {
	table := qb{{title .Name}}Table
	return &{{title .Name}}Type{
	{{- range .Columns}}
		qb{{title $.Name}}F{{title .Name}}.Copy(&table),
	{{- end}}
		&table,
	}
}
{{- else -}}
// {{title .Name}} enum values
const (
{{- range .Colums}}
	Enum{{title $.Name}}{{.Name}} = {{quote .Name}}{{end}}
)
{{end}}
`
